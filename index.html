<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <title>untitled</title>
        <meta http-equiv="content-type" content="text/html;charset=utf-8" />
        <script type="text/javascript" src="assets/javascript/jquery-1.4.2.min.js"></script>
        <script type="text/javascript" src="assets/javascript/flot/excanvas.min.js"></script>
        <script type="text/javascript" src="assets/javascript/flot/jquery.flot.min.js"></script>
        <script type="text/javascript" src="assets/javascript/flot/jquery.flot.selection.min.js"></script>
        <script type="text/javascript" src="assets/javascript/javascriptrrd/binaryXHR.js"></script>
        <script type="text/javascript" src="assets/javascript/javascriptrrd/rrdFile.js"></script>
        <script type="text/javascript" src="assets/javascript/MochiKit/Base.js"></script>
        <script type="text/javascript" src="assets/javascript/MochiKit/Async.js"></script>
        <script type="text/javascript">

        function downloadBinary(url) {
            var d = new MochiKit.Async.Deferred();

            $.ajax({
                url: url,
                dataType: 'text',
                cache: false,
                beforeSend: function(request) {
                    try {
                        request.overrideMimeType('text/plain; charset=x-user-defined');
                    } catch(e) {
                        // IE doesn't support overrideMimeType
                    }
                },
                success: function(data) {
                    try {
                        d.callback(new BinaryFile(data));
                    } catch(e) {
                        d.errback(e);
                    }
                },
                error: function(xhr, textStatus, errorThrown) {
                    // Special case for IE which handles binary data slightly
                    // differently.
                    if(textStatus == 'parsererror') {
                        if (typeof xhr.responseBody != 'undefined') {
                            return this.success(xhr.responseBody);
                        }
                    }
                    d.errback(new Error(xhr.status));
                }
            });
            return d;
        }

        var RrdQuery = function(rrd) {
            this.rrd = rrd;
        }

        RrdQuery.prototype = {
            getData: function(startTime, endTime) {
                var startTimestamp = startTime.getTime()/1000;
                var endTimestamp = endTime.getTime()/1000;

                var consolidationFunc = 'AVERAGE';
                var lastUpdated = this.rrd.getLastUpdate();

                var bestRRA = null;
                for(var i=0; i<this.rrd.getNrRRAs(); i++) {
                    // Look through all RRAs looking for the most suitable
                    // data resolution.
                    var rra = this.rrd.getRRA(i);

                    if(rra.getCFName() != consolidationFunc) {
                        continue;
                    }
                    bestRRA = rra;
                    var step = rra.getStep();
                    var rraRowCount = rra.getNrRows();
                    var firstUpdated = lastUpdated - (rraRowCount - 1) * step;
                    if(firstUpdated <= startTimestamp) {
                        break;
                    }
                }

                if(!bestRRA) {
                    throw new Error('Unrecognised consolidation function: ' + consolidationFunc);
                }

                startRow = rraRowCount - parseInt((lastUpdated - startTimestamp)/step);
                endRow = rraRowCount - parseInt((lastUpdated - endTimestamp)/step);
                returnData = [];
                for(var d=this.rrd.getNrDSs()-1; d>=0; d--) {
                    flotData = [];
                    timestamp = firstUpdated + (startRow - 1) * step;
                    for (var i=startRow; i<=endRow; i++) {
                        var val = bestRRA.getEl(i, d);
                        flotData.push([timestamp*1000.0, val]);
                        timestamp += step;
                    }
                    returnData.push({label: this.rrd.getDS(d).getName(), data: flotData});
                }
                return returnData;
            }
        };


        var RrdQueryRemote = function(url) {
            this.url = url;
            this.rrd = null;
        }

        RrdQueryRemote.prototype = {
            getData: function(startTime, endTime) {
                var endTimestamp = endTime.getTime()/1000;

                var d, self = this;
                if(!this.rrd || this.rrd.getLastUpdate() < endTimestamp) {
                    d = downloadBinary(this.url)
                            .addCallback(
                                function(binary) {
                                    var rrd = new RRDFile(binary);
                                    self.rrd = rrd;
                                    return rrd;
                                });
                } else {
                    d = new MochiKit.Async.Deferred()
                    d.callback(this.rrd);
                }

                d.addCallback(
                    function(rrd) {
                        return new RrdQuery(rrd).getData(startTime, endTime);
                    });

                return d;
            }
        };

        var graphOptions = {
            grid: {
                clickable: true
            },
            selection: {
                mode: 'x'
            },
            series: {
                points: { show: false },
                lines: {
                    show: true,
                    steps: false,
                    shadowSize: 0,
                    lineWidth: 1
                },
                shadowSize: 0
            },
            xaxis: {
                mode: "time"
            }
        };

        function drawChart(db, startTime, endTime) {
            return db.getData(startTime, endTime)
                .addCallback(
                    function(data) {
                        var plot = $.plot($('.container'), data, graphOptions);
                    })
                .addErrback(
                    function(failure) {
                        $('.container').text('error: ' + failure.message);
                    });
        }

        var db = new RrdQueryRemote('data/localhost/load/load.rrd');

        $(function() {
            drawChart(db, new Date('7 April 2010 09:30:00'),
                          new Date('7 April 2010 15:00:00'));

            $('.container').bind('plotclick', function(event, pos, item) {
                if (item) {
                    console.log(['X: ' + new Date(item.datapoint[0]), 'Y: ' + item.datapoint[1]]);
                }
            });

            $('.container').bind("plotselected", function(event, ranges) {
                var startTime = new Date(ranges.xaxis.from);
                var endTime = new Date(ranges.xaxis.to);
                drawChart(db, startTime, endTime);
                console.log("You selected " + startTime + " to " + endTime);
            });
        });
        </script>
    </head>

    <body>
        <div class="container" style="width:100%; height:200px;"></div>
    </body>
</html>
